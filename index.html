<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Map Duck V55 - iOS UI Fix</title>
    <style>
        body {
            background-color: #050505; color: #fff; font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            text-align: center; margin: 0; padding: 0;
            overflow: hidden; height: 100vh; width: 100vw;
            user-select: none; -webkit-user-select: none;
            touch-action: none;
        }

        /* --- UIãƒˆã‚°ãƒ«ãƒœã‚¿ãƒ³ (å³ä¸Šã¸ç§»å‹•) --- */
        #ui-toggle-btn {
            position: absolute; top: 15px; right: 15px; z-index: 100;
            background: rgba(50, 50, 50, 0.8); color: #fff; border: 1px solid #999;
            padding: 8px 12px; cursor: pointer; border-radius: 8px; 
            font-weight: bold; font-size: 16px;
            backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        /* --- UIãƒ‘ãƒãƒ«ãƒ¬ã‚¤ãƒ¤ãƒ¼ (å³å´é…ç½®) --- */
        #ui-layer {
            position: absolute; top: 60px; right: 15px; z-index: 20;
            text-align: left; pointer-events: none;
            max-height: calc(100vh - 100px); overflow-y: auto; 
            display: flex; flex-direction: column; gap: 10px;
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s;
            transform: translateX(0); opacity: 1;
            /* ãƒ‘ãƒãƒ«å†…ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«è¨±å¯ */
            -webkit-overflow-scrolling: touch; touch-action: pan-y;
            padding-bottom: 20px; /* ä¸‹éƒ¨ä½™ç™½ */
        }
        
        /* éš ã™ã¨ãã¯å³ã¸ã‚¹ãƒ©ã‚¤ãƒ‰ */
        #ui-layer.hidden { transform: translateX(120%); opacity: 0; pointer-events: none; }
        
        .panel {
            background: rgba(20, 20, 30, 0.95); padding: 12px; border-radius: 12px; 
            border: 1px solid #666; pointer-events: auto; width: 260px;
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
        }

        /* ã‚¹ãƒãƒ›ç”¨: ç”»é¢å¹…ãŒç‹­ã„æ™‚ã¯å°‘ã—å°ã•ã */
        @media (max-width: 360px) { .panel { width: 220px; } }

        #floor-list {
            margin-bottom: 5px; border-bottom: 1px solid #555; padding-bottom: 5px;
            max-height: 100px; overflow-y: auto;
        }
        .floor-item {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.3); padding: 8px; margin-bottom: 4px; 
            cursor: pointer; border: 1px solid #444; border-radius: 6px;
        }
        .floor-item.active { background: #3e48d6; border-color: #fff; }

        h1 { margin: 0 0 8px 0; font-size: 18px; color: #ffd700; border-bottom:1px solid #555; text-align: center;}
        
        .btn {
            background: #444; color: white; border: 1px solid #fff;
            padding: 10px; cursor: pointer; font-size: 14px; margin-bottom: 6px;
            display: inline-block; width: 100%; box-sizing: border-box; text-align: center; border-radius: 8px;
        }
        .btn:active { transform: scale(0.96); background: #666; }
        .btn-blue { background: #3e48d6; }
        .btn-green { background: #228b22; }
        .btn-yellow { background: #daa520; color: #000; font-weight: bold; }
        .btn-red { background: #8b0000; border-color: #f55; }
        .btn-cyan { background: #008b8b; border-color: #0ff; color:#fff;}
        .btn-purple { background: #800080; border-color: #f0f; }
        .btn-toggle.active { background: #d63e3e; border: 1px solid #f55; }

        input[type="file"] { display: none; }
        label.btn { display: inline-block; }
        
        .slider-row { margin-bottom: 12px; font-size: 12px; }
        input[type=range] { width: 100%; height: 24px; }

        #game-container { position: relative; width: 100%; height: 100%; background-color: #111; }
        canvas { display: block; image-rendering: pixelated; width: 100%; height: 100%; object-fit: contain; }

        /* ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 300; pointer-events: auto; opacity: 0;
            transition: opacity 0.3s; display: flex; flex-direction: column; align-items: center; justify-content: center;
            visibility: hidden; 
        }
        #overlay.show { opacity: 1; visibility: visible; }
        #goal-message { font-size: 40px; color: gold; font-weight: bold; text-shadow: 0 0 20px orange; margin-bottom: 10px; }
        #material-preview { border: 2px solid #fff; width: 300px; height: 300px; background: #000; object-fit: contain; max-width: 90%; }
        #material-controls { margin-top: 20px; text-align: center; }
        .dl-btn { background: #008CBA; color: white; padding: 12px 24px; text-decoration: none; font-size: 16px; border-radius: 8px; display: inline-block; cursor: pointer; border:none; }
        .close-btn { margin-top: 30px; color: #aaa; cursor: pointer; text-decoration: underline; font-size: 16px; padding: 10px; }

        /* ãƒŸãƒ‹ãƒãƒƒãƒ— */
        #minimap-container {
            position: absolute; top: 15px; left: 15px; z-index: 30; /* å·¦ä¸Šã«ç§»å‹• */
            border: 2px solid #fff; background: #000;
            cursor: pointer; transition: all 0.3s ease; width: 100px; overflow: hidden; border-radius: 4px;
        }
        #minimap { width: 100%; display: block; height: auto; }
        #minimap-container.expanded {
            width: 90vmin; top: 50%; left: 50%; right: auto;
            transform: translate(-50%, -50%); border: 4px solid #ffd700; z-index: 200;
        }

        #editor-ui { border-top: 1px dashed #555; margin-top: 10px; padding-top: 10px; display: none; }
        .palette { display: flex; flex-wrap: wrap; gap: 8px; margin-top:5px; justify-content: center; }
        .p-item {
            width: 44px; height: 44px; border: 1px solid #444; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; background: #222; border-radius: 8px;
        }
        .p-item.selected { border-color: #fff; background: #555; box-shadow: 0 0 6px #fff; }
        
        #status { margin-top:10px; font-size:12px; color:#ffcc00; white-space: pre-wrap; text-align: center; }
        
        /* ã‚¹ãƒãƒ›ç”¨ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ */
        #d-pad { 
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); 
            z-index: 40; display: none; width: 240px;
        }
        .d-row { display: flex; justify-content: center; }
        .d-btn { 
            width: 64px; height: 64px; background: rgba(255, 255, 255, 0.15); 
            border: 2px solid rgba(255,255,255,0.3); margin: 6px; border-radius: 16px; 
            line-height: 60px; font-size: 32px; color: #fff; backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
        }
        .d-btn:active { background: rgba(255, 255, 255, 0.4); }

        #nfc-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,50,0.9); z-index: 300; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }
        #nfc-overlay.show { display: flex; }
        #nfc-icon { font-size: 80px; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <button id="ui-toggle-btn">âš™ï¸ ãƒ¡ãƒ‹ãƒ¥ãƒ¼</button>

    <!-- éš ã—ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ› -->
    <input type="file" id="fileInput" accept="image/*">
    <input type="file" id="heroInput" accept="image/*">
    <input type="file" id="loadDataInput" accept=".json">

    <div id="nfc-overlay">
        <div id="nfc-icon">ğŸ“¡</div>
        <h2 id="nfc-status">ã‚¿ã‚°ã‚’ã‚¹ã‚­ãƒ£ãƒ³ä¸­...</h2>
        <p style="font-size:12px; color:#ccc;">â€»Android Chromeã®ã¿å¯¾å¿œ</p>
        <button class="btn" style="width:150px; margin-top:20px;" onclick="document.getElementById('nfc-overlay').classList.remove('show')">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>

    <div id="overlay">
        <div id="goal-message">GOAL!!</div>
        <div id="pattern-name">Visuals Generating...</div>
        <canvas id="material-preview" width="512" height="512"></canvas>
        <div id="material-controls">
            <button id="record-btn" class="dl-btn">ğŸ“¹ å‹•ç”»ä¿å­˜ (.webm)</button>
            <div id="rec-status" style="margin-top:10px; font-size:12px; color:#ffcc00;"></div>
        </div>
        <div class="close-btn" id="close-overlay">é–‰ã˜ã¦æ¢ç´¢ã‚’ç¶šã‘ã‚‹</div>
    </div>

    <div id="ui-layer">
        <div class="panel">
            <h1>Map Duck V55</h1>
            
            <div style="display:flex; gap:5px; margin-bottom:10px;">
                <button class="btn btn-cyan" id="saveDataBtn">ğŸ’¾ ä¿å­˜</button>
                <button class="btn btn-cyan" id="loadDataBtn">ğŸ“‚ èª­è¾¼</button>
            </div>

            <div id="floor-list"></div>
            <button class="btn btn-blue" id="addFloorBtn">ï¼‹ éšã‚’è¿½åŠ </button>
            
            <div style="margin-top:10px; border-top:1px dashed #555; padding-top:10px;">
                <button class="btn btn-green" id="selectImageBtn">ğŸ“‚ ç”»åƒã‚’é¸æŠ</button>
            </div>
            
            <button class="btn btn-yellow" id="guideBtn" style="margin-top:5px;">ğŸ¦† ã‚¬ã‚¤ãƒ‰</button>
            <button class="btn" style="background:#444; margin-top:2px;" id="selectHeroBtn">ğŸ¥ ã‚­ãƒ£ãƒ©å¤‰æ›´</button>
        </div>

        <div class="panel">
            <h1>NFC & ç·¨é›†</h1>
            <button id="nfcReadBtn" class="btn btn-purple">ğŸ“¡ NFCèª­å–</button>
            <button id="nfcWriteBtn" class="btn btn-purple">âœï¸ NFCæ›¸è¾¼</button>
            
            <hr style="border:0; border-top:1px solid #555;">

            <button id="viewToggleBtn" class="btn">ğŸ‘ï¸ å…ƒç”»åƒ / ğŸ° RPG</button>
            <button id="playModeBtn" class="btn btn-green">ğŸ® ãƒ—ãƒ¬ã‚¤ãƒ¢ãƒ¼ãƒ‰</button>
            <button id="editToggleBtn" class="btn btn-toggle">ğŸ› ï¸ ç·¨é›†ãƒ¢ãƒ¼ãƒ‰</button>
            
            <div id="editor-ui">
                <div class="palette">
                    <div class="p-item" data-type="select" title="âœ‹ è¨­å®š/é¸æŠ">âœ‹</div>
                    <div class="p-item" data-type="stairs_up" title="ğŸ“¶ éšæ®µ/EV">ğŸ“¶</div>
                    <div class="p-item" data-type="goal" title="ğŸŒŸ ã‚´ãƒ¼ãƒ«">ğŸŒŸ</div>
                    <div class="p-item" data-type="spawn" title="ğŸ ã‚¹ã‚¿ãƒ¼ãƒˆ">ğŸ</div>
                    <div class="p-item selected" data-type="wall" title="ğŸ§± å£">ğŸ§±</div>
                    <div class="p-item" data-type="floor" title="â¬œ åºŠ">â¬œ</div>
                    <div class="p-item" data-type="concrete" title="ğŸ›£ï¸ å¤–">ğŸ›£ï¸</div>
                    <div class="p-item" data-type="eraser" title="âŒ å‰Šé™¤">âŒ</div>
                </div>
                <div class="slider-group" style="margin-top:10px;">
                    <div class="slider-row">âš¡ ç·šæ¤œå‡º: <input type="range" id="sliderEdge" min="10" max="150" value="50"></div>
                    <div class="slider-row">ğŸŒ‘ ã‚¤ãƒ³ã‚¯: <input type="range" id="sliderBlack" min="0" max="255" value="150"></div>
                </div>
            </div>
            <div id="status">æº–å‚™å®Œäº†</div>
            <button class="btn btn-red" id="resetBtn" style="margin-top:10px;">âš ï¸ å…¨ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
    </div>

    <div id="minimap-container" title="ã‚¯ãƒªãƒƒã‚¯ã§æ‹¡å¤§"><canvas id="minimap"></canvas></div>
    <div id="game-container"><canvas id="gameCanvas"></canvas></div>
    
    <div id="d-pad">
        <div class="d-row"><div class="d-btn" id="btn-up">â–²</div></div>
        <div class="d-row"><div class="d-btn" id="btn-left">â—€</div><div class="d-btn" id="btn-down">â–¼</div><div class="d-btn" id="btn-right">â–¶</div></div>
    </div>

<script>
    // --- è¨­å®š ---
    const MAP_RES = 600; TILE_SIZE = 8; MOVE_SPEED = 0.8; GUIDE_SPEED = 0.35; GUIDE_WAIT_DIST = 18.0;

    // --- ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•° ---
    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
    const miniCanvas = document.getElementById('minimap'); const miniCtx = miniCanvas.getContext('2d');
    const minimapContainer = document.getElementById('minimap-container');
    const statusDiv = document.getElementById('status');
    const overlay = document.getElementById('overlay');
    const matCanvas = document.getElementById('material-preview'); const matCtx = matCanvas.getContext('2d');
    const recBtn = document.getElementById('record-btn');
    const uiToggleBtn = document.getElementById('ui-toggle-btn'); const uiLayer = document.getElementById('ui-layer');
    const nfcOverlay = document.getElementById('nfc-overlay'); const nfcStatus = document.getElementById('nfc-status');

    let floors = []; let curFloorIdx = 0;
    let player = { x: 0, y: 0 }; let camera = { x: 0, y: 0 };
    let guideNPC = { x: 0, y: 0, active: false, path: [], facingRight: true, isWaiting: false };
    
    let isEditing = false; let currentTool = 'wall'; let isMouseDown = false;
    let showOriginal = false; let heroImage = null; let facingRight = true;
    let pEdge = 50, pBlack = 150;
    const keys = { Up: false, Down: false, Left: false, Right: false };

    class Floor {
        constructor(name) {
            this.name = name; this.imageSrc = null; this.image = null;
            this.cols = 0; this.rows = 0;
            this.grid = []; this.objs = []; this.spawn = null; this.goal = null;
            this.canvas = document.createElement('canvas'); this.ready = false; 
        }
    }

    function init() {
        window.addEventListener('resize', resize); resize();
        minimapContainer.addEventListener('click', () => minimapContainer.classList.toggle('expanded'));
        uiToggleBtn.addEventListener('click', toggleUI);
        
        // Touch support
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            document.getElementById('d-pad').style.display = 'block';
            setupTouchControls();
        }

        addFloor("1éš");
        requestAnimationFrame(loop);
        requestAnimationFrame(materialLoop);
        
        statusDiv.innerText = "ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„";
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
    
    function toggleUI() {
        const isHidden = uiLayer.classList.contains('hidden');
        if(isHidden) {
            uiLayer.classList.remove('hidden');
            uiToggleBtn.innerText = "âš™ï¸ éš ã™";
        } else {
            uiLayer.classList.add('hidden');
            uiToggleBtn.innerText = "âš™ï¸ ãƒ¡ãƒ‹ãƒ¥ãƒ¼";
        }
    }

    // --- ãƒœã‚¿ãƒ³ã¨Inputã®ç´ä»˜ã‘ ---
    document.getElementById('selectImageBtn').onclick = () => document.getElementById('fileInput').click();
    document.getElementById('selectHeroBtn').onclick = () => document.getElementById('heroInput').click();
    document.getElementById('loadDataBtn').onclick = () => document.getElementById('loadDataInput').click();

    // --- Web NFC ---
    document.getElementById('nfcReadBtn').onclick = async () => {
        if (!('NDEFReader' in window)) { alert("iOSã¯Webã§ã®NFCèª­å–ã«æœªå¯¾å¿œã§ã™ã€‚\næ‰‹å‹•ã§ç§»å‹•ã—ã¦ãã ã•ã„ã€‚"); return; }
        nfcOverlay.classList.add('show'); nfcStatus.innerText = "ã‚¿ã‚°ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦ç§»å‹•...";
        try {
            const reader = new NDEFReader(); await reader.scan();
            reader.onreading = event => {
                const decoder = new TextDecoder();
                for (const record of event.message.records) {
                    if (record.recordType === "text") {
                        try {
                            const data = JSON.parse(decoder.decode(record.data));
                            if (data.floor !== undefined && data.x !== undefined) {
                                nfcOverlay.classList.remove('show');
                                alert("ã‚¿ã‚°æ¤œçŸ¥ï¼ãƒ¯ãƒ¼ãƒ—ã—ã¾ã™ã€‚");
                                changeFloor(data.floor); player.x = data.x; player.y = data.y;
                            }
                        } catch (e) {}
                    }
                }
            };
        } catch (e) { alert("NFCã‚¨ãƒ©ãƒ¼: " + e); nfcOverlay.classList.remove('show'); }
    };

    document.getElementById('nfcWriteBtn').onclick = async () => {
        if (!('NDEFReader' in window)) { alert("iOSã¯Webã§ã®NFCæ›¸è¾¼ã«æœªå¯¾å¿œã§ã™ã€‚"); return; }
        const f = getCurFloor(); if(!f) return;
        const dataToWrite = JSON.stringify({ floor: curFloorIdx, x: Math.round(player.x), y: Math.round(player.y) });
        if(!confirm(`ç¾åœ¨ã®å ´æ‰€ã‚’ã‚¿ã‚°ã«æ›¸ãè¾¼ã¿ã¾ã™ã‹ï¼Ÿ`)) return;
        nfcOverlay.classList.add('show'); nfcStatus.innerText = "ã‚¿ã‚°ã‚’ã‹ã–ã—ã¦æ›¸ãè¾¼ã¿...";
        try {
            const writer = new NDEFReader();
            await writer.write({ records: [{ recordType: "text", data: dataToWrite }] });
            nfcOverlay.classList.remove('show'); alert("æ›¸ãè¾¼ã¿æˆåŠŸï¼");
        } catch (e) { nfcOverlay.classList.remove('show'); alert("å¤±æ•—: " + e); }
    };

    // --- Load/Save ---
    document.getElementById('saveDataBtn').onclick = () => {
        const d = { floors: floors.map(f => ({ name: f.name, imageSrc: f.imageSrc, cols: f.cols, rows: f.rows, grid: f.grid, objs: f.objs, spawn: f.spawn, goal: f.goal })), player, curFloorIdx };
        const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify(d)], {type: "application/json"})); a.download = "map_duck_data.json"; a.click();
    };
    document.getElementById('loadDataInput').onchange = (e) => {
        const r = new FileReader(); r.onload = evt => {
            try {
                const data = JSON.parse(evt.target.result);
                floors = []; let cnt = 0;
                data.floors.forEach((fd) => {
                    const f = new Floor(fd.name); Object.assign(f, fd); floors.push(f);
                    if(f.imageSrc) { const i = new Image(); i.onload = () => { f.image = i; f.canvas.width=f.cols*TILE_SIZE; f.canvas.height=f.rows*TILE_SIZE; redrawFloor(f); f.ready=true; cnt++; if(cnt===data.floors.length){curFloorIdx=data.curFloorIdx; player=data.player; updateFloorList(); changeFloor(curFloorIdx); alert("èª­è¾¼å®Œäº†");} }; i.src = f.imageSrc; }
                    else { f.ready=true; cnt++; if(cnt===data.floors.length){curFloorIdx=data.curFloorIdx; updateFloorList(); changeFloor(curFloorIdx);} }
                });
            } catch(err) { alert("ãƒ‡ãƒ¼ã‚¿ç ´æ"); }
        }; r.readAsText(e.target.files[0]); e.target.value = "";
    };

    // --- ç”»åƒèª­ã¿è¾¼ã¿ (V53 Fix) ---
    document.getElementById('fileInput').onchange = (e) => {
        const file = e.target.files[0]; if(!file) return;
        const f = getCurFloor(); if(!f) { alert("ãƒ•ãƒ­ã‚¢é¸æŠå¿…é ˆ"); return; }
        statusDiv.innerText = "èª­è¾¼ä¸­...";
        const reader = new FileReader();
        reader.onload = (evt) => {
            const img = new Image();
            img.onload = () => {
                f.image = img; f.imageSrc = evt.target.result;
                f.cols = Math.min(MAP_RES, img.width); f.rows = Math.floor(f.cols * (img.height / img.width));
                f.canvas.width = f.cols*TILE_SIZE; f.canvas.height = f.rows*TILE_SIZE;
                
                // å¼·åˆ¶æç”»
                const c = f.canvas.getContext('2d'); c.drawImage(img, 0, 0, f.canvas.width, f.canvas.height);
                f.grid = Array(f.rows).fill().map(()=>Array(f.cols).fill(0));
                f.ready = true; f.objs = []; f.spawn = null; f.goal = null;
                
                respawnPlayer(); updateFloorList(); 
                minimapContainer.style.display = 'block';
                
                statusDiv.innerText = "è¡¨ç¤ºOK. è§£æä¸­...";
                setTimeout(()=>{ 
                    try{ autoAnalyze(f); statusDiv.innerText = "è§£æå®Œäº†"; } 
                    catch(e){ statusDiv.innerText = "æ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰"; } 
                }, 100);
            };
            img.src = evt.target.result;
        };
        reader.readAsDataURL(file); e.target.value = "";
    };

    function autoAnalyze(f) {
        const tc = document.createElement('canvas'); tc.width=f.cols; tc.height=f.rows;
        const tctx=tc.getContext('2d'); tctx.drawImage(f.image,0,0,f.cols,f.rows);
        const data=tctx.getImageData(0,0,f.cols,f.rows).data;
        for(let y=0; y<f.rows; y++) for(let x=0; x<f.cols; x++) {
            const i=(y*f.cols+x)*4; if((data[i]+data[i+1]+data[i+2])/3 < pBlack) f.grid[y][x]=1;
        }
        redrawFloor(f);
    }
    
    function redrawFloor(f) {
        const c = f.canvas.getContext('2d');
        c.fillStyle="#111"; c.fillRect(0,0,f.canvas.width,f.canvas.height);
        if(f.image) c.drawImage(f.image, 0, 0, f.canvas.width, f.canvas.height);
        for(let y=0; y<f.rows; y++) for(let x=0; x<f.cols; x++) {
            const px=x*TILE_SIZE, py=y*TILE_SIZE, v=f.grid[y][x];
            if(v===1) { c.fillStyle="rgba(180, 50, 50, 0.6)"; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); }
            else if(v===2) { c.fillStyle="rgba(100, 100, 100, 0.6)"; c.fillRect(px,py,TILE_SIZE,TILE_SIZE); }
        }
    }

    function addFloor(name) {
        const f = new Floor(name || (floors.length+1)+"éš"); floors.push(f);
        changeFloor(floors.length - 1);
    }

    function changeFloor(idx) {
        if(idx < 0 || idx >= floors.length) return;
        curFloorIdx = idx; guideNPC.active = false;
        updateFloorList();
        const f = getCurFloor();
        if(f.ready) {
            statusDiv.innerText = f.name + " ã«ç§»å‹•";
            if(!checkHit(f, player.x, player.y)) {} 
            else if(f.spawn) { player.x=f.spawn.x; player.y=f.spawn.y; }
            else respawnPlayer();
        } else statusDiv.innerText = f.name + " (ç”»åƒæœªè¨­å®š)";
    }
    function getCurFloor() { return floors[curFloorIdx]; }
    function updateFloorList() {
        const list = document.getElementById('floor-list'); list.innerHTML = "";
        floors.forEach((f, i) => {
            const div = document.createElement('div');
            div.className = "floor-item" + (i === curFloorIdx ? " active" : "");
            div.innerHTML = `<span class="floor-name">${i}: ${f.name}</span><span>${f.ready?"âœ…":"ğŸ“„"}</span>`;
            div.onclick = () => changeFloor(i); list.appendChild(div);
        });
    }
    function respawnPlayer() {
        const f=getCurFloor(); if(f.spawn){player.x=f.spawn.x;player.y=f.spawn.y;return;}
        player.x=f.cols/2; player.y=f.rows/2;
    }

    function loop() { if(!overlay.classList.contains('show')) { update(); draw(); drawMini(); } requestAnimationFrame(loop); }
    function update() {
        const f = getCurFloor(); if(!f || !f.ready) return;
        // Guide
        if(guideNPC.active && guideNPC.path.length > 0) {
            const t = guideNPC.path[0];
            const dx = t.x - guideNPC.x, dy = t.y - guideNPC.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist > GUIDE_WAIT_DIST) { guideNPC.isWaiting = true; guideNPC.facingRight = (player.x > guideNPC.x); }
            else {
                guideNPC.isWaiting = false;
                if(dist < 0.2) { guideNPC.x=t.x; guideNPC.y=t.y; guideNPC.path.shift(); }
                else { guideNPC.x+=dx/dist*GUIDE_SPEED; guideNPC.y+=dy/dist*GUIDE_SPEED; guideNPC.facingRight=dx>0; }
                if(guideNPC.path.length===0) guideNPC.active=false;
            }
        }
        // Player
        let mx=0, my=0;
        if(keys.Up) my-=MOVE_SPEED; if(keys.Down) my+=MOVE_SPEED;
        if(keys.Left) { mx-=MOVE_SPEED; facingRight=false; } if(keys.Right) { mx+=MOVE_SPEED; facingRight=true; }
        if(mx!==0 || my!==0) {
            if(!checkHit(f, player.x+mx, player.y)) player.x+=mx;
            if(!checkHit(f, player.x, player.y+my)) player.y+=my;
            checkEvent(f);
        }
        const tx=canvas.width/2 - player.x*TILE_SIZE, ty=canvas.height/2 - player.y*TILE_SIZE;
        camera.x+=(tx-camera.x)*0.2; camera.y+=(ty-camera.y)*0.2;
    }
    function checkHit(f, x, y) {
        if(x<0||x>=f.cols||y<0||y>=f.rows) return true;
        for(let o of f.objs) if(['stairs_up','elevator','spawn','goal'].includes(o.type)) if(Math.abs(o.x-x)<1.5 && Math.abs(o.y-y)<1.5) return false;
        return f.grid[Math.floor(y)][Math.floor(x)] === 1;
    }
    let lastWarp = 0; let goalAchieved = false;
    function checkEvent(f) {
        if(f.goal && !goalAchieved && Math.abs(player.x-f.goal.x)<2 && Math.abs(player.y-f.goal.y)<2) {
            goalAchieved=true; showGoalOverlay();
        }
        if(Date.now()-lastWarp<2000) return;
        for(let o of f.objs) if(['stairs_up','elevator'].includes(o.type) && Math.abs(player.x-o.x)<1.5 && Math.abs(player.y-o.y)<1.5) {
            if(o.targetIdx!==undefined && floors[o.targetIdx]) { lastWarp=Date.now(); changeFloor(o.targetIdx); }
        }
    }

    function draw() {
        ctx.fillStyle="#111"; ctx.fillRect(0,0,canvas.width,canvas.height);
        const f = getCurFloor(); if(!f || !f.ready) { ctx.fillStyle="#fff"; ctx.fillText("ç”»åƒã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„", canvas.width/2, canvas.height/2); return; }
        ctx.save(); ctx.translate(camera.x, camera.y);
        if(showOriginal) ctx.drawImage(f.image, 0, 0, f.cols*TILE_SIZE, f.rows*TILE_SIZE); else ctx.drawImage(f.canvas, 0, 0);
        const s = TILE_SIZE*3;
        for(let o of f.objs) {
            const px=o.x*TILE_SIZE, py=o.y*TILE_SIZE;
            if(o.type==='stairs_up'||o.type==='elevator') {
                ctx.fillStyle=o.type==='elevator'?"#00f":"#0f0"; ctx.fillRect(px-s/2,py-s/2,s,s);
                if(isEditing) { ctx.fillStyle="#fff"; ctx.font="10px sans-serif"; ctx.textAlign="center"; ctx.fillText(o.targetIdx!==undefined?("->"+floors[o.targetIdx].name):"æœªè¨­å®š", px, py-s/2-5); }
            } else { ctx.fillStyle="#a85"; ctx.fillRect(px-s/2,py-s/2,s,s); }
        }
        if(f.goal) { ctx.font="30px serif"; ctx.fillText("ğŸŒŸ", f.goal.x*TILE_SIZE-10, f.goal.y*TILE_SIZE+10); }
        if(f.spawn && isEditing) { ctx.font="20px serif"; ctx.fillText("ğŸ", f.spawn.x*TILE_SIZE-10, f.spawn.y*TILE_SIZE+10); }

        if(guideNPC.active) {
            const gx=guideNPC.x*TILE_SIZE, gy=guideNPC.y*TILE_SIZE;
            ctx.globalAlpha=0.5; drawChar(gx,gy,guideNPC.facingRight,true); ctx.globalAlpha=1.0;
            if(guideNPC.isWaiting) { ctx.fillStyle="#fff"; ctx.font="12px sans-serif"; ctx.fillText("å¾…æ©Ÿä¸­...", gx, gy-25); }
        }
        drawChar(player.x*TILE_SIZE, player.y*TILE_SIZE, facingRight, false);
        ctx.restore();
    }
    
    function drawChar(x, y, right, isGuide) {
        const s = TILE_SIZE*4; ctx.save(); ctx.translate(x,y); if(!right) ctx.scale(-1,1);
        if(heroImage) ctx.drawImage(heroImage,-s/2,-s,s,s); else { ctx.fillStyle=isGuide?"lime":"yellow"; ctx.fillRect(-s/2,-s,s,s); }
        ctx.restore();
    }

    function drawMini() {
        const f = getCurFloor(); if(!f||!f.ready) return;
        miniCanvas.width=f.cols; miniCanvas.height=f.rows;
        if(f.image) miniCtx.drawImage(f.image,0,0,f.cols,f.rows); else miniCtx.drawImage(f.canvas,0,0,f.cols,f.rows);
        miniCtx.fillStyle="red"; miniCtx.fillRect(player.x-2,player.y-2,4,4);
    }
    let matRafId = null;
    function showGoalOverlay() { overlay.classList.add('show'); materialLoop(); }
    function materialLoop() {
        if (!overlay.classList.contains('show')) return;
        const w=matCanvas.width, h=matCanvas.height, t=Date.now()*0.002;
        matCtx.fillStyle="#000"; matCtx.fillRect(0,0,w,h);
        const dDuck = (x,y,s,r) => {
            matCtx.save(); matCtx.translate(x,y); matCtx.rotate(r);
            if(heroImage) matCtx.drawImage(heroImage,-s/2,-s/2,s,s); else { matCtx.fillStyle="yellow"; matCtx.fillRect(-s/2, -s/2, s, s); }
            matCtx.restore();
        };
        for(let i=0; i<10; i++) {
             const x = w/2 + Math.sin(t+i)*100, y = h/2 + Math.cos(t*0.5+i)*100;
             matCtx.save(); matCtx.translate(x,y); matCtx.rotate(t+i);
             if(heroImage) matCtx.drawImage(heroImage,-30,-30,60,60); else { matCtx.fillStyle="yellow"; matCtx.fillRect(-30,-30,60,60); }
             matCtx.restore();
        }
        matRafId = requestAnimationFrame(materialLoop);
    }
    document.getElementById('close-overlay').onclick = () => { overlay.classList.remove('show'); goalAchieved=false; player.x-=3; cancelAnimationFrame(matRafId); };
    recBtn.onclick = () => {
        const stream = matCanvas.captureStream(30); const recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp8' });
        const chunks = []; recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'duck_material.webm'; a.click();
            recStatus.innerText = "ä¿å­˜å®Œäº†"; recBtn.disabled=false;
        };
        recorder.start(); recBtn.disabled=true; recStatus.innerText = "éŒ²ç”»ä¸­..."; setTimeout(() => recorder.stop(), 3000);
    };

    // UI
    document.getElementById('editToggleBtn').onclick = () => { isEditing=!isEditing; document.getElementById('editor-ui').style.display=isEditing?"block":"none"; statusDiv.innerText = isEditing?"ç·¨é›†ãƒ¢ãƒ¼ãƒ‰":"æ¢ç´¢ãƒ¢ãƒ¼ãƒ‰"; };
    document.getElementById('playModeBtn').onclick = () => { isEditing=false; document.getElementById('editor-ui').style.display="none"; uiLayer.classList.add('hidden'); uiToggleBtn.innerText="âš™ï¸ UI"; };
    document.getElementById('viewToggleBtn').onclick = () => showOriginal=!showOriginal;
    document.querySelectorAll('.p-item').forEach(el=>el.onclick=function(){ document.querySelectorAll('.p-item').forEach(i=>i.classList.remove('selected')); this.classList.add('selected'); currentTool=this.dataset.type; });
    
    function setupTouchControls() {
        const bind = (id, k) => { const b=document.getElementById(id); b.ontouchstart=e=>{e.preventDefault();keys[k]=true}; b.ontouchend=e=>{e.preventDefault();keys[k]=false}; };
        bind('btn-up','Up'); bind('btn-down','Down'); bind('btn-left','Left'); bind('btn-right','Right');
        canvas.addEventListener('touchstart', e=>{if(isEditing){e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY, true);}}, {passive:false});
        canvas.addEventListener('touchmove', e=>{if(isEditing){e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY, false);}}, {passive:false});
    }
    
    canvas.onmousedown = e => { if(isEditing) handleInput(e.clientX, e.clientY, true); };
    canvas.onmousemove = e => { if(isEditing && isMouseDown) handleInput(e.clientX, e.clientY, false); };
    window.onmouseup = () => isMouseDown=false;
    
    function handleInput(cx, cy, click) {
        if(click) isMouseDown=true;
        const r=canvas.getBoundingClientRect(), gx=Math.floor((cx-r.left-camera.x)/TILE_SIZE), gy=Math.floor((cy-r.top-camera.y)/TILE_SIZE);
        const f=getCurFloor(); if(!f) return;
        if(click && currentTool==='select') {
            const o = f.objs.find(ob => Math.abs(ob.x-gx)<3);
            if(o && ['stairs_up','elevator'].includes(o.type)) { o.targetIdx = parseInt(prompt("éšç•ªå·?", o.targetIdx||0)); }
        }
        else if(click && ['spawn','goal','stairs_up','elevator'].includes(currentTool)) {
            if(currentTool==='spawn') f.spawn={x:gx,y:gy};
            else if(currentTool==='goal') f.goal={x:gx,y:gy};
            else f.objs.push({x:gx,y:gy,type:currentTool});
            for(let dy=-1; dy<=1; dy++) for(let dx=-1; dx<=1; dx++) if(gy+dy>=0 && gy+dy<f.rows && gx+dx>=0 && gx+dx<f.cols) f.grid[gy+dy][gx+dx]=0;
            redrawFloor(f);
        }
        else if(['wall','floor','concrete','eraser'].includes(currentTool)) {
            if(currentTool==='wall') f.grid[gy][gx]=1;
            else if(currentTool==='concrete') f.grid[gy][gx]=2;
            else { f.grid[gy][gx]=0; if(currentTool==='eraser') f.objs=f.objs.filter(o=>Math.abs(o.x-gx)>2); }
            redrawFloor(f);
        }
    }
    
    // ã‚¬ã‚¤ãƒ‰
    document.getElementById('guideBtn').onclick = () => {
        const f = getCurFloor(); if(!f.goal) {alert("ã‚´ãƒ¼ãƒ«è¨­å®šå¿…è¦"); return;}
        statusDiv.innerText="çµŒè·¯è¨ˆç®—ä¸­...";
        setTimeout(() => {
            let open=[{x:Math.round(player.x),y:Math.round(player.y),g:0,h:0,p:null}], closed=new Set();
            let end={x:f.goal.x,y:f.goal.y};
            if(f.grid[end.y][end.x]===1) {
                for(let r=1; r<20; r++) for(let dy=-r; dy<=r; dy++) for(let dx=-r; dx<=r; dx++) 
                    if(f.grid[end.y+dy] && f.grid[end.y+dy][end.x+dx]===0) { end.x+=dx; end.y+=dy; break; }
            }
            let found=null;
            for(let i=0; i<15000 && open.length>0; i++) {
                open.sort((a,b)=>(a.g+a.h)-(b.g+b.h));
                let curr=open.shift();
                if(Math.abs(curr.x-end.x)<2 && Math.abs(curr.y-end.y)<2) { found=curr; break; }
                if(closed.has(curr.x+","+curr.y)) continue; closed.add(curr.x+","+curr.y);
                [[0,1],[0,-1],[1,0],[-1,0]].forEach(d=>{
                     let nx=curr.x+d[0], ny=curr.y+d[1];
                     if(nx>=0 && nx<f.cols && ny>=0 && ny<f.rows && f.grid[ny][nx]!==1) 
                        open.push({x:nx,y:ny,g:curr.g+1,h:Math.abs(nx-end.x)+Math.abs(ny-end.y),p:curr});
                });
            }
            if(found) {
                let path=[]; while(found.p){path.push({x:found.x,y:found.y}); found=found.p;}
                guideNPC={x:player.x, y:player.y, active:true, path:path.reverse(), facingRight:true, isWaiting:false};
                statusDiv.innerText="ã‚¬ã‚¤ãƒ‰é–‹å§‹";
            } else statusDiv.innerText="çµŒè·¯ãªã—";
        }, 10);
    };

    document.getElementById('autoOutsideBtn').onclick = () => {
        const f = getCurFloor(); if(!f.ready) return;
        const q = [[0,0],[f.cols-1,0],[0,f.rows-1],[f.cols-1,f.rows-1]];
        const v = new Set();
        while(q.length>0) {
            const [x,y]=q.pop(); const k=x+","+y; if(v.has(k))continue; v.add(k);
            if(x>=0&&x<f.cols&&y>=0&&y<f.rows && f.grid[y][x]!==1) {
                f.grid[y][x]=2; q.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
            }
        }
        redrawFloor(f);
    };

    window.onkeydown = e => { if(e.code.includes('Arrow')) keys[e.code.replace('Arrow','')] = true; };
    window.onkeyup = e => { if(e.code.includes('Arrow')) keys[e.code.replace('Arrow','')] = false; };
    document.getElementById('sliderBlack').addEventListener('change', e => { pBlack=e.target.value; try{autoAnalyze(getCurFloor());}catch(e){} });
    document.getElementById('addFloorBtn').onclick = () => addFloor(prompt("éšã®åå‰"));
    document.getElementById('heroInput').onchange = e => { const r=new FileReader(); r.onload=ev=>{heroImage=new Image(); heroImage.src=ev.target.result;}; r.readAsDataURL(e.target.files[0]); };
    document.getElementById('resetBtn').onclick = () => location.reload();

    init();
</script>
</body>
</html>
